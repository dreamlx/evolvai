# Story 2.4: Interactive Confirmation for High-Risk Operations (Draft)

**创建日期**: 2025-01-14
**状态**: [DRAFT] - Design Notes
**优先级**: P1 - Epic-001 Phase 2 Enhancement
**来源**: Story 2.3 Review中用户洞察

---

## 📋 用户洞察（关键发现）

**场景描述**：
> "很多时候AI理解用户的模糊命令，比如'清理一下'，'这个删除一下'，在上下文环境不理解的情况下就会有灾难性操作。"

**问题本质**：
- Story 2.3检测：**显性推理崩溃**（rm -rf /）
- Story 2.4需检测：**隐性推理失败**（上下文误解导致的错误操作）

---

## 🎯 核心场景

### 场景1：范围误判
```
用户："清理一下"
上下文：在/project目录讨论构建缓存
AI误解：清理整个项目 → rm -rf /project
正确：清理构建目录 → rm -rf /project/build
```

### 场景2：目标混淆
```
用户："这个删除一下"
上下文：讨论test文件和src文件
AI指代错误：误以为"这个"=src目录 → rm -rf ./src
正确："这个"=test文件 → rm ./test/old_test.py
```

### 场景3：通配符操作（用户最关注）
```
用户："清理临时文件"
AI生成：rm -rf ./tmp_*
风险：可能误删 ./tmp_important_backup/
需要：用户确认具体会删除哪些文件
```

---

## 💡 设计方案

### 核心决策：交互确认机制

**用户决策**：
> "我觉得交互确认已经非常足够了，尤其是通配符操作"

**设计原则**：
- ✅ 简单直接（KISS）
- ✅ 用户可控（最终决策权）
- ✅ 灵活性高（不会误报阻止）

---

## 🏗️ 技术设计

### 两级检测系统

```python
# Level 1: 绝对荒谬（直接阻止，Story 2.3已实现）
ABSURD_PATTERNS = [
    (r'rm\s+-rf\s+/\s*$', "rm_rf_root"),
    (r'rm\s+-rf\s+/\*', "rm_rf_root_wildcard"),
    (r'mkfs\.', "mkfs"),
    (r':\(\)\{.*:\|:.*\}.*;:', "fork_bomb"),
]
→ 行为：直接抛出 ConstraintViolationError

# Level 2: 需要确认（Story 2.4新增）
CONFIRMATION_REQUIRED_PATTERNS = [
    # 优先级P0：通配符删除
    (r'rm\s+-rf?\s+.*\*', "wildcard_delete",
     "Deleting with wildcard - please confirm exact target"),

    # 优先级P1：删除当前目录
    (r'rm\s+-rf\s+\./?$', "delete_current_dir",
     "Deleting current directory - please confirm"),

    # 优先级P2：删除源代码目录（可选）
    (r'rm\s+-rf\s+\./(src|lib|pkg)/?$', "delete_source_dir",
     "Deleting source code directory - please confirm"),
]
→ 行为：返回 confirmation_required=True
```

---

## 📊 数据结构扩展

### ExecutionResult扩展

```python
@dataclass
class ExecutionResult:
    success: bool
    exit_code: int
    stdout: str
    stderr: str
    duration_ms: float
    precondition_passed: bool
    error_message: Optional[str] = None

    # Story 2.4新增
    confirmation_required: bool = False
    confirmation_message: Optional[str] = None
    risk_level: str = "low"  # "low", "medium", "high"
```

---

## 🎬 用户交互流程

### 流程1：通配符删除
```
Step 1: AI生成命令
  Command: rm -rf ./tmp_*

Step 2: safe_exec检测到通配符
  Result: confirmation_required=True

Step 3: AI询问用户
  AI: ⚠️  High-risk operation detected: Deleting with wildcard
      Command: rm -rf ./tmp_*

      This will delete all files/directories matching: ./tmp_*
      Please confirm you want to proceed.

      Do you want to proceed? (yes/no)

Step 4: 用户响应
  User: yes

Step 5: AI重新执行（with confirmation flag）
  safe_exec.execute("rm -rf ./tmp_*", confirmed=True)
```

---

## 🎯 Story 2.4 实施范围

### Phase 1: Core Infrastructure (Day 1)
- [ ] 扩展 ExecutionResult 数据结构
- [ ] 实现 CONFIRMATION_REQUIRED_PATTERNS 检测
- [ ] 添加 confirmation_required 返回机制
- [ ] 单元测试（10-12个测试用例）

### Phase 2: Confirmation Flow (Day 2)
- [ ] 实现 confirmed 参数支持
- [ ] ToolExecutionEngine 集成
- [ ] AI工具层自动询问机制
- [ ] 集成测试

### Phase 3: MCP Integration (Day 3)
- [ ] MCP协议支持 confirmation_required
- [ ] Dashboard显示确认请求
- [ ] 用户确认UI（如果需要）
- [ ] 端到端测试

---

## 🔗 与其他Story的关系

### 依赖
- **Story 2.3**: PreconditionChecker基础架构 ✅
- **Story 1.2**: ToolExecutionEngine审计日志 ✅

### 集成
- **ExecutionPlan (Day 3)**:
  - 可以在ExecutionPlan中预授权某些高风险操作
  - `ExecutionPlan(pre_confirmed_operations=["rm -rf ./build/*"])`

### 后续
- **Story 2.5**: 根据实际使用数据优化规则
- **Story 2.6**: 智能通配符展开（显示具体会删除哪些文件）

---

## 📏 验收标准

### 功能完整性
- [ ] F1: 检测通配符删除操作
- [ ] F2: 检测删除当前目录操作
- [ ] F3: 返回 confirmation_required 结果
- [ ] F4: 支持 confirmed=True 参数跳过二次检测
- [ ] F5: MCP工具层自动询问用户

### 质量标准
- [ ] Q1: 测试覆盖率 ≥ 90%
- [ ] Q2: 误报率 < 5%（不能过度阻止正常操作）
- [ ] Q3: 向后兼容（不破坏Story 2.3功能）

### 性能标准
- [ ] P1: Precondition检查仍然 < 10ms
- [ ] P2: 交互确认不影响非高风险操作性能

---

## 💭 设计讨论记录

### 为什么选择"交互确认"而非"直接阻止"？

**用户决策**：
> "我觉得交互确认已经非常足够了，尤其是通配符操作"

**分析**：
- ✅ 用户保留最终控制权
- ✅ 避免误报阻止合理操作（如 `rm -rf ./build/*` 是常见清理）
- ✅ 符合KISS原则（不需要复杂的语义分析）
- ✅ TPST友好（一轮确认 vs 多轮错误重试）

### 为什么不在Story 2.3中实现？

**决策**：
- Story 2.3专注基础架构（PreconditionChecker + ProcessManager）
- 交互确认需要完整的AI工具层支持
- 与ExecutionPlan一起设计更合理（可以预授权）
- 避免Story 2.3范围蔓延

### 权衡分析

| 方案 | 优势 | 劣势 | 结论 |
|------|------|------|------|
| 直接阻止 | 最安全 | 误报率高，限制灵活性 | ❌ 不采用 |
| ExecutionPlan授权 | 可预配置 | 需要用户预知所有操作 | ✅ 辅助机制 |
| 交互确认 | 灵活、用户可控 | 增加一轮交互 | ✅ **主方案** |
| 智能分析 | 精确 | 复杂、延迟高 | ❌ 过度设计 |

---

## 📝 待讨论问题

1. **通配符展开**：是否需要在确认时显示具体会删除哪些文件？
   - 优势：用户更清楚影响范围
   - 劣势：需要执行 `ls` 或 `find` 命令，增加延迟

2. **确认缓存**：是否需要在同一会话中记住用户的确认？
   - 场景：用户确认 `rm -rf ./build/*` 后，5分钟内再次执行是否需要重新确认？
   - 建议：不缓存（安全优先）

3. **批量确认**：如果AI计划执行多个高风险操作，是否支持一次性确认？
   - 场景：清理多个目录
   - 建议：Story 2.5考虑

---

## 🔖 标签
`epic-001` `phase-2` `safe-operations` `interactive-confirmation` `high-risk-detection` `user-insight`

---

**记录人**: Claude Code
**审阅人**: 待定
**决策状态**: Draft - 待Story 2.3完成后启动
